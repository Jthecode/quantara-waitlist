{
  "version": 3,
  "sources": ["api-client.ts"],
  "sourcesContent": ["// public/scripts/api-client.ts\r\n// Tiny typed client for your serverless endpoints.\r\n//\r\n// Build step: transpile to JS (e.g. esbuild/tsup) and include the compiled file\r\n// with <script type=\"module\" src=\"/scripts/api-client.js\"></script>\r\n\r\nimport type {\r\n  ApiResponse,\r\n  GetResponse,\r\n  PostResponse,\r\n  EndpointMap,\r\n  PostEndpointMap,\r\n  FetchJsonOptions,\r\n  JSONObject,\r\n} from \"../../types/api.js\"; // NOTE: .js suffix required with NodeNext\r\n\r\n// ---------- Type helpers: pick success branch & its data --------------------\r\ntype Ok<T> = T extends { ok: true } ? T : never;\r\ntype OkData<T> = T extends { ok: true; data: infer D } ? D : never;\r\n\r\n// ----- Internal fetcher ------------------------------------------------------\r\n\r\nconst DEFAULT_TIMEOUT_MS = 10_000;\r\n\r\nfunction makeTimeoutSignal(\r\n  upstream: AbortSignal | null | undefined,\r\n  ms: number = DEFAULT_TIMEOUT_MS\r\n): { signal: AbortSignal | undefined; clear: () => void } {\r\n  if (!ms) return { signal: upstream ?? undefined, clear: () => {} };\r\n\r\n  const controller = new AbortController();\r\n  const timer = setTimeout(() => controller.abort(), ms);\r\n  const clear = () => clearTimeout(timer);\r\n\r\n  if (upstream) {\r\n    if (upstream.aborted) controller.abort();\r\n    else upstream.addEventListener(\"abort\", () => controller.abort(), { once: true });\r\n  }\r\n\r\n  return { signal: controller.signal, clear };\r\n}\r\n\r\nasync function doFetch<T extends ApiResponse<any>>(\r\n  path: string,\r\n  init: RequestInit & { timeoutMs?: number } = {}\r\n): Promise<Ok<T>> {\r\n  const { timeoutMs, ...rest } = init;\r\n  const { signal, clear } = makeTimeoutSignal(rest.signal, timeoutMs ?? DEFAULT_TIMEOUT_MS);\r\n\r\n  const headers = new Headers(rest.headers || {});\r\n  if (rest.body && typeof rest.body === \"string\" && !headers.has(\"Content-Type\")) {\r\n    headers.set(\"Content-Type\", \"application/json\");\r\n  }\r\n  if (!headers.has(\"Accept\")) headers.set(\"Accept\", \"application/json\");\r\n\r\n  let res: Response;\r\n  try {\r\n    res = await fetch(path, {\r\n      credentials: \"same-origin\",\r\n      ...rest,\r\n      headers,\r\n      signal,\r\n    });\r\n  } finally {\r\n    clear();\r\n  }\r\n\r\n  // Some APIs may return 204 No Content or empty body\r\n  const text = await res.text();\r\n  let parsed: unknown = null;\r\n  if (text) {\r\n    try {\r\n      parsed = JSON.parse(text);\r\n    } catch {\r\n      parsed = { ok: res.ok, status: res.status, message: text };\r\n    }\r\n  }\r\n\r\n  const json = (parsed ?? { ok: res.ok, data: undefined }) as ApiResponse<unknown>;\r\n\r\n  // Normalize errors to ApiError-like shapes and throw them\r\n  if (!res.ok || (json as any).ok === false) {\r\n    const err =\r\n      (json as any).ok === false\r\n        ? (json as any)\r\n        : {\r\n            ok: false,\r\n            status: res.status,\r\n            code: res.statusText || \"HTTP_ERROR\",\r\n            message:\r\n              (json as any)?.message ||\r\n              `Request failed (${res.status}${res.statusText ? \" \" + res.statusText : \"\"})`,\r\n          };\r\n    throw err;\r\n  }\r\n\r\n  // At this point `json.ok` is true\r\n  return json as Ok<T>;\r\n}\r\n\r\n// ----- Public typed helpers --------------------------------------------------\r\n\r\n// GET helper\r\nexport async function get<Path extends keyof EndpointMap>(\r\n  path: Path,\r\n  opts: Omit<FetchJsonOptions, \"method\" | \"body\"> & { timeoutMs?: number } = {}\r\n): Promise<OkData<GetResponse<Path>>> {\r\n  const res = await doFetch<GetResponse<Path>>(path as string, { method: \"GET\", ...opts });\r\n  return res.data as OkData<GetResponse<Path>>;\r\n}\r\n\r\n// POST helper\r\nexport async function post<Path extends keyof PostEndpointMap, Body extends JSONObject>(\r\n  path: Path,\r\n  body: Body,\r\n  opts: Omit<FetchJsonOptions<Body>, \"method\" | \"body\"> & { timeoutMs?: number } = {}\r\n): Promise<OkData<PostResponse<Path>>> {\r\n  const res = await doFetch<PostResponse<Path>>(path as string, {\r\n    method: \"POST\",\r\n    body: JSON.stringify(body),\r\n    ...opts,\r\n  });\r\n  return res.data as OkData<PostResponse<Path>>;\r\n}\r\n\r\n// ----- Convenience: DOM hydrators (optional) --------------------------------\r\n\r\n/** Fill small config bits in the DOM (rpc url, network name, releaseAt). */\r\nexport async function hydrateConfig() {\r\n  const cfg = await get(\"/api/config\");\r\n  const rpcEl = document.getElementById(\"rpc-url\");\r\n  if (rpcEl) rpcEl.textContent = cfg.rpcWS;\r\n\r\n  const badge = document.getElementById(\"live-badge\");\r\n  if (badge) badge.textContent = \"Preview\";\r\n\r\n  const fmt = new Intl.DateTimeFormat(undefined, { dateStyle: \"medium\", timeStyle: \"short\" });\r\n  [\"preview-release-time\", \"preview-release-time-2\"].forEach((id) => {\r\n    const t = document.getElementById(id) as HTMLTimeElement | null;\r\n    if (t) {\r\n      t.dateTime = cfg.releaseAt;\r\n      t.textContent = fmt.format(new Date(cfg.releaseAt));\r\n    }\r\n  });\r\n  return cfg;\r\n}\r\n\r\n/** Fill live metrics in the DOM (height, peers, counters). */\r\nexport async function hydrateMetrics() {\r\n  const m = await get(\"/api/metrics\");\r\n\r\n  const height = document.getElementById(\"height\");\r\n  if (height && typeof m.height === \"number\") height.textContent = m.height.toLocaleString();\r\n\r\n  const peers = document.getElementById(\"peers\");\r\n  if (peers && typeof m.peers === \"number\") peers.textContent = String(m.peers);\r\n\r\n  const map: Record<string, number | undefined> = {\r\n    waitlist: m.waitlistCount,\r\n    countries: m.countryCount,\r\n  };\r\n\r\n  document.querySelectorAll<HTMLElement>(\"[data-countup-key]\").forEach((el) => {\r\n    const key = el.getAttribute(\"data-countup-key\")!;\r\n    const end = map[key];\r\n    if (typeof end !== \"number\") {\r\n      el.closest(\"[data-hide-if-empty]\")?.classList.add(\"hidden\");\r\n      return;\r\n    }\r\n    animateCountup(el, end);\r\n  });\r\n\r\n  return m;\r\n}\r\n\r\nfunction animateCountup(el: HTMLElement, end: number, dur = 900) {\r\n  const start = performance.now();\r\n  const startVal = 0;\r\n  const step = (t: number) => {\r\n    const k = Math.min(1, (t - start) / dur);\r\n    const cur = Math.floor(startVal + (end - startVal) * k);\r\n    el.textContent = cur.toLocaleString();\r\n    if (k < 1) requestAnimationFrame(step);\r\n  };\r\n  requestAnimationFrame(step);\r\n}\r\n\r\n// ----- Optional: expose on window for quick prototyping ---------------------\r\n\r\ndeclare global {\r\n  interface Window {\r\n    Api?: {\r\n      get: typeof get;\r\n      post: typeof post;\r\n      hydrateConfig: typeof hydrateConfig;\r\n      hydrateMetrics: typeof hydrateMetrics;\r\n    };\r\n  }\r\n}\r\n\r\nif (typeof window !== \"undefined\") {\r\n  window.Api = { get, post, hydrateConfig, hydrateMetrics };\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
